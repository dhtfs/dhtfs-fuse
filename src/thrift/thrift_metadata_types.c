/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "thrift_metadata_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_FileSystemModel(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case THRIFT_FILE_SYSTEM_MODEL_PASTIS:return "THRIFT_FILE_SYSTEM_MODEL_PASTIS";
  case THRIFT_FILE_SYSTEM_MODEL_BASIC:return "THRIFT_FILE_SYSTEM_MODEL_BASIC";
  case THRIFT_FILE_SYSTEM_MODEL_SNAPSHOT:return "THRIFT_FILE_SYSTEM_MODEL_SNAPSHOT";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_InodeType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case THRIFT_INODE_TYPE_FILE:return "THRIFT_INODE_TYPE_FILE";
  case THRIFT_INODE_TYPE_DIRECTORY:return "THRIFT_INODE_TYPE_DIRECTORY";
  case THRIFT_INODE_TYPE_SYMLINK:return "THRIFT_INODE_TYPE_SYMLINK";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_InodeFlags(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case THRIFT_INODE_FLAGS_EXECUTABLE:return "THRIFT_INODE_FLAGS_EXECUTABLE";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_DirEntryDiffType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case THRIFT_DIR_ENTRY_DIFF_TYPE_ADD:return "THRIFT_DIR_ENTRY_DIFF_TYPE_ADD";
  case THRIFT_DIR_ENTRY_DIFF_TYPE_REMOVE:return "THRIFT_DIR_ENTRY_DIFF_TYPE_REMOVE";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _ThriftFileSystemProperties
{
  PROP_THRIFT_FILE_SYSTEM_0,
  PROP_THRIFT_FILE_SYSTEM_NAME,
  PROP_THRIFT_FILE_SYSTEM_BLOCK_SIZE,
  PROP_THRIFT_FILE_SYSTEM_ROOT,
  PROP_THRIFT_FILE_SYSTEM_INCEPTION,
  PROP_THRIFT_FILE_SYSTEM_MODEL
};

/* reads a file_system object */
static gint32
thrift_file_system_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftFileSystem * this_object = THRIFT_FILE_SYSTEM(object);
  gboolean isset_name = FALSE;
  gboolean isset_block_size = FALSE;
  gboolean isset_root = FALSE;
  gboolean isset_inception = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->block_size, error)) < 0)
            return -1;
          xfer += ret;
          isset_block_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->root, error)) < 0)
            return -1;
          xfer += ret;
          isset_root = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->inception, error)) < 0)
            return -1;
          xfer += ret;
          isset_inception = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          gint32 ecast0;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast0, error)) < 0)
            return -1;
          xfer += ret;
          this_object->model = (ThriftFileSystemModel)ecast0;
          this_object->__isset_model = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_name)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_block_size)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_root)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_inception)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
thrift_file_system_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftFileSystem * this_object = THRIFT_FILE_SYSTEM(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FileSystem", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "block_size", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->block_size, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "root", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->root, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "inception", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->inception, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "model", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->model, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_file_system_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  ThriftFileSystem *self = THRIFT_FILE_SYSTEM (object);

  switch (property_id)
  {
    case PROP_THRIFT_FILE_SYSTEM_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      break;

    case PROP_THRIFT_FILE_SYSTEM_BLOCK_SIZE:
      self->block_size = g_value_get_int (value);
      break;

    case PROP_THRIFT_FILE_SYSTEM_ROOT:
      self->root = g_value_get_int64 (value);
      break;

    case PROP_THRIFT_FILE_SYSTEM_INCEPTION:
      self->inception = g_value_get_int64 (value);
      break;

    case PROP_THRIFT_FILE_SYSTEM_MODEL:
      self->model = g_value_get_int (value);
      self->__isset_model = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_file_system_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  ThriftFileSystem *self = THRIFT_FILE_SYSTEM (object);

  switch (property_id)
  {
    case PROP_THRIFT_FILE_SYSTEM_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_THRIFT_FILE_SYSTEM_BLOCK_SIZE:
      g_value_set_int (value, self->block_size);
      break;

    case PROP_THRIFT_FILE_SYSTEM_ROOT:
      g_value_set_int64 (value, self->root);
      break;

    case PROP_THRIFT_FILE_SYSTEM_INCEPTION:
      g_value_set_int64 (value, self->inception);
      break;

    case PROP_THRIFT_FILE_SYSTEM_MODEL:
      g_value_set_int (value, self->model);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_file_system_instance_init (ThriftFileSystem * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->block_size = 0;
  object->root = 0;
  object->inception = 0;
  object->__isset_model = FALSE;
}

static void 
thrift_file_system_finalize (GObject *object)
{
  ThriftFileSystem *tobject = THRIFT_FILE_SYSTEM (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
}

static void
thrift_file_system_class_init (ThriftFileSystemClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_file_system_read;
  struct_class->write = thrift_file_system_write;

  gobject_class->finalize = thrift_file_system_finalize;
  gobject_class->get_property = thrift_file_system_get_property;
  gobject_class->set_property = thrift_file_system_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_FILE_SYSTEM_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_FILE_SYSTEM_BLOCK_SIZE,
     g_param_spec_int ("block_size",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_FILE_SYSTEM_ROOT,
     g_param_spec_int64 ("root",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_FILE_SYSTEM_INCEPTION,
     g_param_spec_int64 ("inception",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_FILE_SYSTEM_MODEL,
     g_param_spec_int ("model",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));
}

GType
thrift_file_system_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftFileSystemClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_file_system_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftFileSystem),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_file_system_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftFileSystemType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftFileDataProperties
{
  PROP_THRIFT_FILE_DATA_0,
  PROP_THRIFT_FILE_DATA_SIZE,
  PROP_THRIFT_FILE_DATA_BLOCKS,
  PROP_THRIFT_FILE_DATA_INDIRECT
};

/* reads a file_data object */
static gint32
thrift_file_data_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftFileData * this_object = THRIFT_FILE_DATA(object);
  gboolean isset_size = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->size, error)) < 0)
            return -1;
          xfer += ret;
          isset_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem1 = NULL;
              if (_elem1 != NULL)
              {
                g_free(_elem1);
                _elem1 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem1 = g_byte_array_new();
              g_byte_array_append (_elem1, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->blocks, _elem1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_blocks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem2 = NULL;
              if (_elem2 != NULL)
              {
                g_free(_elem2);
                _elem2 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem2 = g_byte_array_new();
              g_byte_array_append (_elem2, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->indirect, _elem2);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_indirect = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_size)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
thrift_file_data_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftFileData * this_object = THRIFT_FILE_DATA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FileData", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "size", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->size, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "blocks", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i3;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->blocks ? this_object->blocks->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i3 = 0; i3 < (this_object->blocks ? this_object->blocks->len : 0); i3++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->blocks, i3)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->blocks, i3)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->blocks, i3)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->blocks, i3)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "indirect", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i4;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->indirect ? this_object->indirect->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i4 = 0; i4 < (this_object->indirect ? this_object->indirect->len : 0); i4++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->indirect, i4)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->indirect, i4)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->indirect, i4)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->indirect, i4)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_file_data_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  ThriftFileData *self = THRIFT_FILE_DATA (object);

  switch (property_id)
  {
    case PROP_THRIFT_FILE_DATA_SIZE:
      self->size = g_value_get_int64 (value);
      break;

    case PROP_THRIFT_FILE_DATA_BLOCKS:
      if (self->blocks != NULL)
        g_ptr_array_unref (self->blocks);
      self->blocks = g_value_dup_boxed (value);
      self->__isset_blocks = TRUE;
      break;

    case PROP_THRIFT_FILE_DATA_INDIRECT:
      if (self->indirect != NULL)
        g_ptr_array_unref (self->indirect);
      self->indirect = g_value_dup_boxed (value);
      self->__isset_indirect = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_file_data_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  ThriftFileData *self = THRIFT_FILE_DATA (object);

  switch (property_id)
  {
    case PROP_THRIFT_FILE_DATA_SIZE:
      g_value_set_int64 (value, self->size);
      break;

    case PROP_THRIFT_FILE_DATA_BLOCKS:
      g_value_set_boxed (value, self->blocks);
      break;

    case PROP_THRIFT_FILE_DATA_INDIRECT:
      g_value_set_boxed (value, self->indirect);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_file_data_instance_init (ThriftFileData * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->size = 0;
  object->blocks = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_blocks = FALSE;
  object->indirect = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_indirect = FALSE;
}

static void 
thrift_file_data_finalize (GObject *object)
{
  ThriftFileData *tobject = THRIFT_FILE_DATA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->blocks != NULL)
  {
    g_ptr_array_unref (tobject->blocks);
    tobject->blocks = NULL;
  }
  if (tobject->indirect != NULL)
  {
    g_ptr_array_unref (tobject->indirect);
    tobject->indirect = NULL;
  }
}

static void
thrift_file_data_class_init (ThriftFileDataClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_file_data_read;
  struct_class->write = thrift_file_data_write;

  gobject_class->finalize = thrift_file_data_finalize;
  gobject_class->get_property = thrift_file_data_get_property;
  gobject_class->set_property = thrift_file_data_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_FILE_DATA_SIZE,
     g_param_spec_int64 ("size",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_FILE_DATA_BLOCKS,
     g_param_spec_boxed ("blocks",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_FILE_DATA_INDIRECT,
     g_param_spec_boxed ("indirect",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
thrift_file_data_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftFileDataClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_file_data_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftFileData),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_file_data_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftFileDataType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftFileDataIndirectProperties
{
  PROP_THRIFT_FILE_DATA_INDIRECT_0,
  PROP_THRIFT_FILE_DATA_INDIRECT_BLOCKS,
  PROP_THRIFT_FILE_DATA_INDIRECT_VALID
};

/* reads a file_data_indirect object */
static gint32
thrift_file_data_indirect_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftFileDataIndirect * this_object = THRIFT_FILE_DATA_INDIRECT(object);
  gboolean isset_blocks = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem5 = NULL;
              if (_elem5 != NULL)
              {
                g_free(_elem5);
                _elem5 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem5 = g_byte_array_new();
              g_byte_array_append (_elem5, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->blocks, _elem5);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_blocks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->valid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_valid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_blocks)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
thrift_file_data_indirect_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftFileDataIndirect * this_object = THRIFT_FILE_DATA_INDIRECT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FileDataIndirect", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "blocks", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i6;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->blocks ? this_object->blocks->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i6 = 0; i6 < (this_object->blocks ? this_object->blocks->len : 0); i6++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->blocks, i6)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->blocks, i6)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->blocks, i6)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->blocks, i6)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "valid", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->valid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_file_data_indirect_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  ThriftFileDataIndirect *self = THRIFT_FILE_DATA_INDIRECT (object);

  switch (property_id)
  {
    case PROP_THRIFT_FILE_DATA_INDIRECT_BLOCKS:
      if (self->blocks != NULL)
        g_ptr_array_unref (self->blocks);
      self->blocks = g_value_dup_boxed (value);
      break;

    case PROP_THRIFT_FILE_DATA_INDIRECT_VALID:
      self->valid = g_value_get_boolean (value);
      self->__isset_valid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_file_data_indirect_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  ThriftFileDataIndirect *self = THRIFT_FILE_DATA_INDIRECT (object);

  switch (property_id)
  {
    case PROP_THRIFT_FILE_DATA_INDIRECT_BLOCKS:
      g_value_set_boxed (value, self->blocks);
      break;

    case PROP_THRIFT_FILE_DATA_INDIRECT_VALID:
      g_value_set_boolean (value, self->valid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_file_data_indirect_instance_init (ThriftFileDataIndirect * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->blocks = g_ptr_array_new_with_free_func (thrift_string_free);
  object->valid = 1;
  object->__isset_valid = FALSE;
}

static void 
thrift_file_data_indirect_finalize (GObject *object)
{
  ThriftFileDataIndirect *tobject = THRIFT_FILE_DATA_INDIRECT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->blocks != NULL)
  {
    g_ptr_array_unref (tobject->blocks);
    tobject->blocks = NULL;
  }
}

static void
thrift_file_data_indirect_class_init (ThriftFileDataIndirectClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_file_data_indirect_read;
  struct_class->write = thrift_file_data_indirect_write;

  gobject_class->finalize = thrift_file_data_indirect_finalize;
  gobject_class->get_property = thrift_file_data_indirect_get_property;
  gobject_class->set_property = thrift_file_data_indirect_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_FILE_DATA_INDIRECT_BLOCKS,
     g_param_spec_boxed ("blocks",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_FILE_DATA_INDIRECT_VALID,
     g_param_spec_boolean ("valid",
                           NULL,
                           NULL,
                           TRUE,
                           G_PARAM_READWRITE));
}

GType
thrift_file_data_indirect_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftFileDataIndirectClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_file_data_indirect_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftFileDataIndirect),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_file_data_indirect_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftFileDataIndirectType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftDirEntryProperties
{
  PROP_THRIFT_DIR_ENTRY_0,
  PROP_THRIFT_DIR_ENTRY_INUMBER,
  PROP_THRIFT_DIR_ENTRY_TYPE
};

/* reads a dir_entry object */
static gint32
thrift_dir_entry_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftDirEntry * this_object = THRIFT_DIR_ENTRY(object);
  gboolean isset_inumber = FALSE;
  gboolean isset_type = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->inumber, error)) < 0)
            return -1;
          xfer += ret;
          isset_inumber = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast7;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast7, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (ThriftInodeType)ecast7;
          isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_inumber)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_type)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
thrift_dir_entry_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftDirEntry * this_object = THRIFT_DIR_ENTRY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DirEntry", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "inumber", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->inumber, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_dir_entry_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  ThriftDirEntry *self = THRIFT_DIR_ENTRY (object);

  switch (property_id)
  {
    case PROP_THRIFT_DIR_ENTRY_INUMBER:
      self->inumber = g_value_get_int64 (value);
      break;

    case PROP_THRIFT_DIR_ENTRY_TYPE:
      self->type = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_dir_entry_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  ThriftDirEntry *self = THRIFT_DIR_ENTRY (object);

  switch (property_id)
  {
    case PROP_THRIFT_DIR_ENTRY_INUMBER:
      g_value_set_int64 (value, self->inumber);
      break;

    case PROP_THRIFT_DIR_ENTRY_TYPE:
      g_value_set_int (value, self->type);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_dir_entry_instance_init (ThriftDirEntry * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->inumber = 0;
}

static void 
thrift_dir_entry_finalize (GObject *object)
{
  ThriftDirEntry *tobject = THRIFT_DIR_ENTRY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
thrift_dir_entry_class_init (ThriftDirEntryClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_dir_entry_read;
  struct_class->write = thrift_dir_entry_write;

  gobject_class->finalize = thrift_dir_entry_finalize;
  gobject_class->get_property = thrift_dir_entry_get_property;
  gobject_class->set_property = thrift_dir_entry_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_DIR_ENTRY_INUMBER,
     g_param_spec_int64 ("inumber",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_DIR_ENTRY_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));
}

GType
thrift_dir_entry_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftDirEntryClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_dir_entry_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftDirEntry),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_dir_entry_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftDirEntryType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftDirEntryDiffProperties
{
  PROP_THRIFT_DIR_ENTRY_DIFF_0,
  PROP_THRIFT_DIR_ENTRY_DIFF_DIFF_TYPE,
  PROP_THRIFT_DIR_ENTRY_DIFF_ENTRY,
  PROP_THRIFT_DIR_ENTRY_DIFF_MTIME,
  PROP_THRIFT_DIR_ENTRY_DIFF_NAME
};

/* reads a dir_entry_diff object */
static gint32
thrift_dir_entry_diff_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftDirEntryDiff * this_object = THRIFT_DIR_ENTRY_DIFF(object);
  gboolean isset_diff_type = FALSE;
  gboolean isset_entry = FALSE;
  gboolean isset_mtime = FALSE;
  gboolean isset_name = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast8;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->diff_type = (ThriftDirEntryDiffType)ecast8;
          isset_diff_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->entry), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_entry = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->mtime, error)) < 0)
            return -1;
          xfer += ret;
          isset_mtime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_diff_type)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_entry)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_mtime)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_name)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
thrift_dir_entry_diff_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftDirEntryDiff * this_object = THRIFT_DIR_ENTRY_DIFF(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DirEntryDiff", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "diff_type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->diff_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "entry", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->entry), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mtime", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->mtime, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_dir_entry_diff_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  ThriftDirEntryDiff *self = THRIFT_DIR_ENTRY_DIFF (object);

  switch (property_id)
  {
    case PROP_THRIFT_DIR_ENTRY_DIFF_DIFF_TYPE:
      self->diff_type = g_value_get_int (value);
      break;

    case PROP_THRIFT_DIR_ENTRY_DIFF_ENTRY:
      if (self->entry != NULL)
        g_object_unref (self->entry);
      self->entry = g_value_dup_object (value);
      break;

    case PROP_THRIFT_DIR_ENTRY_DIFF_MTIME:
      self->mtime = g_value_get_int64 (value);
      break;

    case PROP_THRIFT_DIR_ENTRY_DIFF_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_dir_entry_diff_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  ThriftDirEntryDiff *self = THRIFT_DIR_ENTRY_DIFF (object);

  switch (property_id)
  {
    case PROP_THRIFT_DIR_ENTRY_DIFF_DIFF_TYPE:
      g_value_set_int (value, self->diff_type);
      break;

    case PROP_THRIFT_DIR_ENTRY_DIFF_ENTRY:
      g_value_set_object (value, self->entry);
      break;

    case PROP_THRIFT_DIR_ENTRY_DIFF_MTIME:
      g_value_set_int64 (value, self->mtime);
      break;

    case PROP_THRIFT_DIR_ENTRY_DIFF_NAME:
      g_value_set_string (value, self->name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_dir_entry_diff_instance_init (ThriftDirEntryDiff * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->entry = g_object_new (THRIFT_TYPE_DIR_ENTRY, NULL);
  object->mtime = 0;
  object->name = NULL;
}

static void 
thrift_dir_entry_diff_finalize (GObject *object)
{
  ThriftDirEntryDiff *tobject = THRIFT_DIR_ENTRY_DIFF (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->entry != NULL)
  {
    g_object_unref(tobject->entry);
    tobject->entry = NULL;
  }
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
}

static void
thrift_dir_entry_diff_class_init (ThriftDirEntryDiffClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_dir_entry_diff_read;
  struct_class->write = thrift_dir_entry_diff_write;

  gobject_class->finalize = thrift_dir_entry_diff_finalize;
  gobject_class->get_property = thrift_dir_entry_diff_get_property;
  gobject_class->set_property = thrift_dir_entry_diff_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_DIR_ENTRY_DIFF_DIFF_TYPE,
     g_param_spec_int ("diff_type",
                       NULL,
                       NULL,
                       0,
                       1,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_DIR_ENTRY_DIFF_ENTRY,
     g_param_spec_object ("entry",
                         NULL,
                         NULL,
                         THRIFT_TYPE_DIR_ENTRY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_DIR_ENTRY_DIFF_MTIME,
     g_param_spec_int64 ("mtime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_DIR_ENTRY_DIFF_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
thrift_dir_entry_diff_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftDirEntryDiffClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_dir_entry_diff_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftDirEntryDiff),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_dir_entry_diff_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftDirEntryDiffType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftDirDataProperties
{
  PROP_THRIFT_DIR_DATA_0,
  PROP_THRIFT_DIR_DATA_ENTRIES,
  PROP_THRIFT_DIR_DATA_COUNT,
  PROP_THRIFT_DIR_DATA_INDIRECT
};

/* reads a dir_data object */
static gint32
thrift_dir_data_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftDirData * this_object = THRIFT_DIR_DATA(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key9 = NULL;
              ThriftDirEntry * val10 = NULL;
              if (key9 != NULL)
              {
                g_free(key9);
                key9 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key9, error)) < 0)
                return -1;
              xfer += ret;
              if ( val10 != NULL)
              {
                g_object_unref (val10);
              }
              val10 = g_object_new (THRIFT_TYPE_DIR_ENTRY, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val10), protocol, error)) < 0)
              {
                g_object_unref (val10);
                return -1;
              }
              xfer += ret;
              if (this_object->entries && key9)
                g_hash_table_insert ((GHashTable *)this_object->entries, (gpointer) key9, (gpointer) val10);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_entries = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->count, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->indirect != NULL)
          {
            g_free(this_object->indirect);
            this_object->indirect = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->indirect = g_byte_array_new();
          g_byte_array_append (this_object->indirect, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_indirect = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_dir_data_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftDirData * this_object = THRIFT_DIR_DATA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DirData", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "entries", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key11 = NULL;
    ThriftDirEntry * val12 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRUCT, this_object->entries ? (gint32) g_hash_table_size ((GHashTable *) this_object->entries) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->entries)
      g_hash_table_foreach ((GHashTable *) this_object->entries, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key11 = keys[i];
      val12 = (ThriftDirEntry *) g_hash_table_lookup (((GHashTable *) this_object->entries), (gpointer) key11);

      if ((ret = thrift_protocol_write_string (protocol,  key11, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_struct_write (THRIFT_STRUCT ( val12), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "count", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->count, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "indirect", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->indirect ? ((GByteArray *) this_object->indirect)->data : NULL, this_object->indirect ? ((GByteArray *) this_object->indirect)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_dir_data_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  ThriftDirData *self = THRIFT_DIR_DATA (object);

  switch (property_id)
  {
    case PROP_THRIFT_DIR_DATA_ENTRIES:
      if (self->entries != NULL)
        g_hash_table_unref (self->entries);
      self->entries = g_value_dup_boxed (value);
      self->__isset_entries = TRUE;
      break;

    case PROP_THRIFT_DIR_DATA_COUNT:
      self->count = g_value_get_int64 (value);
      self->__isset_count = TRUE;
      break;

    case PROP_THRIFT_DIR_DATA_INDIRECT:
      if (self->indirect != NULL)
        g_byte_array_unref (self->indirect);
      self->indirect = g_value_dup_boxed (value);
      self->__isset_indirect = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_dir_data_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  ThriftDirData *self = THRIFT_DIR_DATA (object);

  switch (property_id)
  {
    case PROP_THRIFT_DIR_DATA_ENTRIES:
      g_value_set_boxed (value, self->entries);
      break;

    case PROP_THRIFT_DIR_DATA_COUNT:
      g_value_set_int64 (value, self->count);
      break;

    case PROP_THRIFT_DIR_DATA_INDIRECT:
      g_value_set_boxed (value, self->indirect);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_dir_data_instance_init (ThriftDirData * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->entries = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
  object->__isset_entries = FALSE;
  object->count = 0;
  object->__isset_count = FALSE;
  object->indirect = NULL;
  object->__isset_indirect = FALSE;
}

static void 
thrift_dir_data_finalize (GObject *object)
{
  ThriftDirData *tobject = THRIFT_DIR_DATA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->entries != NULL)
  {
    g_hash_table_destroy (tobject->entries);
    tobject->entries = NULL;
  }
  if (tobject->indirect != NULL)
  {
    thrift_string_free(tobject->indirect);
    tobject->indirect = NULL;
  }
}

static void
thrift_dir_data_class_init (ThriftDirDataClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_dir_data_read;
  struct_class->write = thrift_dir_data_write;

  gobject_class->finalize = thrift_dir_data_finalize;
  gobject_class->get_property = thrift_dir_data_get_property;
  gobject_class->set_property = thrift_dir_data_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_DIR_DATA_ENTRIES,
     g_param_spec_boxed ("entries",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_DIR_DATA_COUNT,
     g_param_spec_int64 ("count",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_DIR_DATA_INDIRECT,
     g_param_spec_boxed ("indirect",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
thrift_dir_data_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftDirDataClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_dir_data_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftDirData),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_dir_data_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftDirDataType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftDirDataIndirectProperties
{
  PROP_THRIFT_DIR_DATA_INDIRECT_0,
  PROP_THRIFT_DIR_DATA_INDIRECT_ENTRIES,
  PROP_THRIFT_DIR_DATA_INDIRECT_VALID
};

/* reads a dir_data_indirect object */
static gint32
thrift_dir_data_indirect_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftDirDataIndirect * this_object = THRIFT_DIR_DATA_INDIRECT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key13 = NULL;
              ThriftDirEntry * val14 = NULL;
              if (key13 != NULL)
              {
                g_free(key13);
                key13 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key13, error)) < 0)
                return -1;
              xfer += ret;
              if ( val14 != NULL)
              {
                g_object_unref (val14);
              }
              val14 = g_object_new (THRIFT_TYPE_DIR_ENTRY, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val14), protocol, error)) < 0)
              {
                g_object_unref (val14);
                return -1;
              }
              xfer += ret;
              if (this_object->entries && key13)
                g_hash_table_insert ((GHashTable *)this_object->entries, (gpointer) key13, (gpointer) val14);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_entries = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->valid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_valid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_dir_data_indirect_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftDirDataIndirect * this_object = THRIFT_DIR_DATA_INDIRECT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DirDataIndirect", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "entries", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key15 = NULL;
    ThriftDirEntry * val16 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRUCT, this_object->entries ? (gint32) g_hash_table_size ((GHashTable *) this_object->entries) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->entries)
      g_hash_table_foreach ((GHashTable *) this_object->entries, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key15 = keys[i];
      val16 = (ThriftDirEntry *) g_hash_table_lookup (((GHashTable *) this_object->entries), (gpointer) key15);

      if ((ret = thrift_protocol_write_string (protocol,  key15, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_struct_write (THRIFT_STRUCT ( val16), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "valid", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->valid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_dir_data_indirect_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  ThriftDirDataIndirect *self = THRIFT_DIR_DATA_INDIRECT (object);

  switch (property_id)
  {
    case PROP_THRIFT_DIR_DATA_INDIRECT_ENTRIES:
      if (self->entries != NULL)
        g_hash_table_unref (self->entries);
      self->entries = g_value_dup_boxed (value);
      self->__isset_entries = TRUE;
      break;

    case PROP_THRIFT_DIR_DATA_INDIRECT_VALID:
      self->valid = g_value_get_boolean (value);
      self->__isset_valid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_dir_data_indirect_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  ThriftDirDataIndirect *self = THRIFT_DIR_DATA_INDIRECT (object);

  switch (property_id)
  {
    case PROP_THRIFT_DIR_DATA_INDIRECT_ENTRIES:
      g_value_set_boxed (value, self->entries);
      break;

    case PROP_THRIFT_DIR_DATA_INDIRECT_VALID:
      g_value_set_boolean (value, self->valid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_dir_data_indirect_instance_init (ThriftDirDataIndirect * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->entries = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
  object->__isset_entries = FALSE;
  object->valid = 1;
  object->__isset_valid = FALSE;
}

static void 
thrift_dir_data_indirect_finalize (GObject *object)
{
  ThriftDirDataIndirect *tobject = THRIFT_DIR_DATA_INDIRECT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->entries != NULL)
  {
    g_hash_table_destroy (tobject->entries);
    tobject->entries = NULL;
  }
}

static void
thrift_dir_data_indirect_class_init (ThriftDirDataIndirectClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_dir_data_indirect_read;
  struct_class->write = thrift_dir_data_indirect_write;

  gobject_class->finalize = thrift_dir_data_indirect_finalize;
  gobject_class->get_property = thrift_dir_data_indirect_get_property;
  gobject_class->set_property = thrift_dir_data_indirect_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_DIR_DATA_INDIRECT_ENTRIES,
     g_param_spec_boxed ("entries",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_DIR_DATA_INDIRECT_VALID,
     g_param_spec_boolean ("valid",
                           NULL,
                           NULL,
                           TRUE,
                           G_PARAM_READWRITE));
}

GType
thrift_dir_data_indirect_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftDirDataIndirectClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_dir_data_indirect_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftDirDataIndirect),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_dir_data_indirect_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftDirDataIndirectType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftSymLinkDataProperties
{
  PROP_THRIFT_SYM_LINK_DATA_0,
  PROP_THRIFT_SYM_LINK_DATA_TARGET
};

/* reads a sym_link_data object */
static gint32
thrift_sym_link_data_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftSymLinkData * this_object = THRIFT_SYM_LINK_DATA(object);
  gboolean isset_target = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->target != NULL)
          {
            g_free(this_object->target);
            this_object->target = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->target, error)) < 0)
            return -1;
          xfer += ret;
          isset_target = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_target)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
thrift_sym_link_data_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftSymLinkData * this_object = THRIFT_SYM_LINK_DATA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SymLinkData", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "target", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->target, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_sym_link_data_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  ThriftSymLinkData *self = THRIFT_SYM_LINK_DATA (object);

  switch (property_id)
  {
    case PROP_THRIFT_SYM_LINK_DATA_TARGET:
      if (self->target != NULL)
        g_free (self->target);
      self->target = g_value_dup_string (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_sym_link_data_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  ThriftSymLinkData *self = THRIFT_SYM_LINK_DATA (object);

  switch (property_id)
  {
    case PROP_THRIFT_SYM_LINK_DATA_TARGET:
      g_value_set_string (value, self->target);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_sym_link_data_instance_init (ThriftSymLinkData * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->target = NULL;
}

static void 
thrift_sym_link_data_finalize (GObject *object)
{
  ThriftSymLinkData *tobject = THRIFT_SYM_LINK_DATA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->target != NULL)
  {
    g_free(tobject->target);
    tobject->target = NULL;
  }
}

static void
thrift_sym_link_data_class_init (ThriftSymLinkDataClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_sym_link_data_read;
  struct_class->write = thrift_sym_link_data_write;

  gobject_class->finalize = thrift_sym_link_data_finalize;
  gobject_class->get_property = thrift_sym_link_data_get_property;
  gobject_class->set_property = thrift_sym_link_data_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_SYM_LINK_DATA_TARGET,
     g_param_spec_string ("target",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
thrift_sym_link_data_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftSymLinkDataClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_sym_link_data_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftSymLinkData),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_sym_link_data_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftSymLinkDataType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftInodeProperties
{
  PROP_THRIFT_INODE_0,
  PROP_THRIFT_INODE_ID,
  PROP_THRIFT_INODE_INUMBER,
  PROP_THRIFT_INODE_TYPE,
  PROP_THRIFT_INODE_MTIME,
  PROP_THRIFT_INODE_FLAGS,
  PROP_THRIFT_INODE_FILE_DATA,
  PROP_THRIFT_INODE_DIRECTORY_DATA,
  PROP_THRIFT_INODE_SYMLINK_DATA
};

/* reads a inode object */
static gint32
thrift_inode_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftInode * this_object = THRIFT_INODE(object);
  gboolean isset_id = FALSE;
  gboolean isset_inumber = FALSE;
  gboolean isset_type = FALSE;
  gboolean isset_mtime = FALSE;
  gboolean isset_flags = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->inumber, error)) < 0)
            return -1;
          xfer += ret;
          isset_inumber = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast17;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast17, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (ThriftInodeType)ecast17;
          isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->mtime, error)) < 0)
            return -1;
          xfer += ret;
          isset_mtime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->flags, error)) < 0)
            return -1;
          xfer += ret;
          isset_flags = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->file_data), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_file_data = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->directory_data), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_directory_data = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->symlink_data), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_symlink_data = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_id)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_inumber)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_type)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_mtime)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_flags)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
thrift_inode_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftInode * this_object = THRIFT_INODE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Inode", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "inumber", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->inumber, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mtime", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->mtime, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "flags", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->flags, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_file_data == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "file_data", T_STRUCT, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->file_data), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_directory_data == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "directory_data", T_STRUCT, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->directory_data), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_symlink_data == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "symlink_data", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->symlink_data), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_inode_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  ThriftInode *self = THRIFT_INODE (object);

  switch (property_id)
  {
    case PROP_THRIFT_INODE_ID:
      self->id = g_value_get_int64 (value);
      break;

    case PROP_THRIFT_INODE_INUMBER:
      self->inumber = g_value_get_int64 (value);
      break;

    case PROP_THRIFT_INODE_TYPE:
      self->type = g_value_get_int (value);
      break;

    case PROP_THRIFT_INODE_MTIME:
      self->mtime = g_value_get_int64 (value);
      break;

    case PROP_THRIFT_INODE_FLAGS:
      self->flags = g_value_get_int (value);
      break;

    case PROP_THRIFT_INODE_FILE_DATA:
      if (self->file_data != NULL)
        g_object_unref (self->file_data);
      self->file_data = g_value_dup_object (value);
      self->__isset_file_data = TRUE;
      break;

    case PROP_THRIFT_INODE_DIRECTORY_DATA:
      if (self->directory_data != NULL)
        g_object_unref (self->directory_data);
      self->directory_data = g_value_dup_object (value);
      self->__isset_directory_data = TRUE;
      break;

    case PROP_THRIFT_INODE_SYMLINK_DATA:
      if (self->symlink_data != NULL)
        g_object_unref (self->symlink_data);
      self->symlink_data = g_value_dup_object (value);
      self->__isset_symlink_data = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_inode_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  ThriftInode *self = THRIFT_INODE (object);

  switch (property_id)
  {
    case PROP_THRIFT_INODE_ID:
      g_value_set_int64 (value, self->id);
      break;

    case PROP_THRIFT_INODE_INUMBER:
      g_value_set_int64 (value, self->inumber);
      break;

    case PROP_THRIFT_INODE_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_THRIFT_INODE_MTIME:
      g_value_set_int64 (value, self->mtime);
      break;

    case PROP_THRIFT_INODE_FLAGS:
      g_value_set_int (value, self->flags);
      break;

    case PROP_THRIFT_INODE_FILE_DATA:
      g_value_set_object (value, self->file_data);
      break;

    case PROP_THRIFT_INODE_DIRECTORY_DATA:
      g_value_set_object (value, self->directory_data);
      break;

    case PROP_THRIFT_INODE_SYMLINK_DATA:
      g_value_set_object (value, self->symlink_data);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_inode_instance_init (ThriftInode * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = 0;
  object->inumber = 0;
  object->mtime = 0;
  object->flags = 0;
  object->file_data = g_object_new (THRIFT_TYPE_FILE_DATA, NULL);
  object->__isset_file_data = FALSE;
  object->directory_data = g_object_new (THRIFT_TYPE_DIR_DATA, NULL);
  object->__isset_directory_data = FALSE;
  object->symlink_data = g_object_new (THRIFT_TYPE_SYM_LINK_DATA, NULL);
  object->__isset_symlink_data = FALSE;
}

static void 
thrift_inode_finalize (GObject *object)
{
  ThriftInode *tobject = THRIFT_INODE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->file_data != NULL)
  {
    g_object_unref(tobject->file_data);
    tobject->file_data = NULL;
  }
  if (tobject->directory_data != NULL)
  {
    g_object_unref(tobject->directory_data);
    tobject->directory_data = NULL;
  }
  if (tobject->symlink_data != NULL)
  {
    g_object_unref(tobject->symlink_data);
    tobject->symlink_data = NULL;
  }
}

static void
thrift_inode_class_init (ThriftInodeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_inode_read;
  struct_class->write = thrift_inode_write;

  gobject_class->finalize = thrift_inode_finalize;
  gobject_class->get_property = thrift_inode_get_property;
  gobject_class->set_property = thrift_inode_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_INODE_ID,
     g_param_spec_int64 ("id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_INODE_INUMBER,
     g_param_spec_int64 ("inumber",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_INODE_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_INODE_MTIME,
     g_param_spec_int64 ("mtime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_INODE_FLAGS,
     g_param_spec_int ("flags",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_INODE_FILE_DATA,
     g_param_spec_object ("file_data",
                         NULL,
                         NULL,
                         THRIFT_TYPE_FILE_DATA,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_INODE_DIRECTORY_DATA,
     g_param_spec_object ("directory_data",
                         NULL,
                         NULL,
                         THRIFT_TYPE_DIR_DATA,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_INODE_SYMLINK_DATA,
     g_param_spec_object ("symlink_data",
                         NULL,
                         NULL,
                         THRIFT_TYPE_SYM_LINK_DATA,
                         G_PARAM_READWRITE));
}

GType
thrift_inode_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftInodeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_inode_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftInode),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_inode_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftInodeType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

