/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "thrift_rpc_types.h"
#include <thrift/c_glib/thrift.h>

enum _ThriftPeerProperties
{
  PROP_THRIFT_PEER_0,
  PROP_THRIFT_PEER_HOST,
  PROP_THRIFT_PEER_PORT
};

/* reads a peer object */
static gint32
thrift_peer_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftPeer * this_object = THRIFT_PEER(object);
  gboolean isset_host = FALSE;
  gboolean isset_port = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->host != NULL)
          {
            g_free(this_object->host);
            this_object->host = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->host, error)) < 0)
            return -1;
          xfer += ret;
          isset_host = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->port, error)) < 0)
            return -1;
          xfer += ret;
          isset_port = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_host)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_port)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
thrift_peer_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftPeer * this_object = THRIFT_PEER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Peer", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "host", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->host, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "port", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->port, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_peer_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  ThriftPeer *self = THRIFT_PEER (object);

  switch (property_id)
  {
    case PROP_THRIFT_PEER_HOST:
      if (self->host != NULL)
        g_free (self->host);
      self->host = g_value_dup_string (value);
      break;

    case PROP_THRIFT_PEER_PORT:
      self->port = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_peer_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  ThriftPeer *self = THRIFT_PEER (object);

  switch (property_id)
  {
    case PROP_THRIFT_PEER_HOST:
      g_value_set_string (value, self->host);
      break;

    case PROP_THRIFT_PEER_PORT:
      g_value_set_int (value, self->port);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_peer_instance_init (ThriftPeer * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->host = NULL;
  object->port = 0;
}

static void 
thrift_peer_finalize (GObject *object)
{
  ThriftPeer *tobject = THRIFT_PEER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->host != NULL)
  {
    g_free(tobject->host);
    tobject->host = NULL;
  }
}

static void
thrift_peer_class_init (ThriftPeerClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_peer_read;
  struct_class->write = thrift_peer_write;

  gobject_class->finalize = thrift_peer_finalize;
  gobject_class->get_property = thrift_peer_get_property;
  gobject_class->set_property = thrift_peer_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_PEER_HOST,
     g_param_spec_string ("host",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_PEER_PORT,
     g_param_spec_int ("port",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
thrift_peer_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftPeerClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_peer_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftPeer),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_peer_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftPeerType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftBucketValueProperties
{
  PROP_THRIFT_BUCKET_VALUE_0,
  PROP_THRIFT_BUCKET_VALUE_SEARCH_KEY,
  PROP_THRIFT_BUCKET_VALUE_VALUE
};

/* reads a bucket_value object */
static gint32
thrift_bucket_value_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftBucketValue * this_object = THRIFT_BUCKET_VALUE(object);
  gboolean isset_search_key = FALSE;
  gboolean isset_value = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->search_key, error)) < 0)
            return -1;
          xfer += ret;
          isset_search_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->value = g_byte_array_new();
          g_byte_array_append (this_object->value, (guint8 *) data, (guint) len);
          g_free (data);
          isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_search_key)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_value)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
thrift_bucket_value_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftBucketValue * this_object = THRIFT_BUCKET_VALUE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BucketValue", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "search_key", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->search_key, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->value ? ((GByteArray *) this_object->value)->data : NULL, this_object->value ? ((GByteArray *) this_object->value)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_bucket_value_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  ThriftBucketValue *self = THRIFT_BUCKET_VALUE (object);

  switch (property_id)
  {
    case PROP_THRIFT_BUCKET_VALUE_SEARCH_KEY:
      self->search_key = g_value_get_int64 (value);
      break;

    case PROP_THRIFT_BUCKET_VALUE_VALUE:
      if (self->value != NULL)
        g_byte_array_unref (self->value);
      self->value = g_value_dup_boxed (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_bucket_value_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  ThriftBucketValue *self = THRIFT_BUCKET_VALUE (object);

  switch (property_id)
  {
    case PROP_THRIFT_BUCKET_VALUE_SEARCH_KEY:
      g_value_set_int64 (value, self->search_key);
      break;

    case PROP_THRIFT_BUCKET_VALUE_VALUE:
      g_value_set_boxed (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_bucket_value_instance_init (ThriftBucketValue * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->search_key = 0;
  object->value = NULL;
}

static void 
thrift_bucket_value_finalize (GObject *object)
{
  ThriftBucketValue *tobject = THRIFT_BUCKET_VALUE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->value != NULL)
  {
    thrift_string_free(tobject->value);
    tobject->value = NULL;
  }
}

static void
thrift_bucket_value_class_init (ThriftBucketValueClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_bucket_value_read;
  struct_class->write = thrift_bucket_value_write;

  gobject_class->finalize = thrift_bucket_value_finalize;
  gobject_class->get_property = thrift_bucket_value_get_property;
  gobject_class->set_property = thrift_bucket_value_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_BUCKET_VALUE_SEARCH_KEY,
     g_param_spec_int64 ("search_key",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_BUCKET_VALUE_VALUE,
     g_param_spec_boxed ("value",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
thrift_bucket_value_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftBucketValueClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_bucket_value_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftBucketValue),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_bucket_value_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftBucketValueType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftBucketProperties
{
  PROP_THRIFT_BUCKET_0,
  PROP_THRIFT_BUCKET_SEARCH_KEY_MIN,
  PROP_THRIFT_BUCKET_SEARCH_KEY_MAX,
  PROP_THRIFT_BUCKET_VALUES
};

/* reads a bucket object */
static gint32
thrift_bucket_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftBucket * this_object = THRIFT_BUCKET(object);
  gboolean isset_search_key_min = FALSE;
  gboolean isset_search_key_max = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->search_key_min, error)) < 0)
            return -1;
          xfer += ret;
          isset_search_key_min = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->search_key_max, error)) < 0)
            return -1;
          xfer += ret;
          isset_search_key_max = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ThriftBucketValue * _elem0 = NULL;
              if ( _elem0 != NULL)
              {
                g_object_unref (_elem0);
              }
              _elem0 = g_object_new (THRIFT_TYPE_BUCKET_VALUE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem0), protocol, error)) < 0)
              {
                g_object_unref (_elem0);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->values, _elem0);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_search_key_min)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_search_key_max)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
thrift_bucket_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftBucket * this_object = THRIFT_BUCKET(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Bucket", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "search_key_min", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->search_key_min, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "search_key_max", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->search_key_max, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "values", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i1;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->values ? this_object->values->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i1 = 0; i1 < (this_object->values ? this_object->values->len : 0); i1++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->values, i1))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_bucket_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  ThriftBucket *self = THRIFT_BUCKET (object);

  switch (property_id)
  {
    case PROP_THRIFT_BUCKET_SEARCH_KEY_MIN:
      self->search_key_min = g_value_get_int64 (value);
      break;

    case PROP_THRIFT_BUCKET_SEARCH_KEY_MAX:
      self->search_key_max = g_value_get_int64 (value);
      break;

    case PROP_THRIFT_BUCKET_VALUES:
      if (self->values != NULL)
        g_ptr_array_unref (self->values);
      self->values = g_value_dup_boxed (value);
      self->__isset_values = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_bucket_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  ThriftBucket *self = THRIFT_BUCKET (object);

  switch (property_id)
  {
    case PROP_THRIFT_BUCKET_SEARCH_KEY_MIN:
      g_value_set_int64 (value, self->search_key_min);
      break;

    case PROP_THRIFT_BUCKET_SEARCH_KEY_MAX:
      g_value_set_int64 (value, self->search_key_max);
      break;

    case PROP_THRIFT_BUCKET_VALUES:
      g_value_set_boxed (value, self->values);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_bucket_instance_init (ThriftBucket * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->search_key_min = 0;
  object->search_key_max = 0;
  object->values = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_values = FALSE;
}

static void 
thrift_bucket_finalize (GObject *object)
{
  ThriftBucket *tobject = THRIFT_BUCKET (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->values != NULL)
  {
    g_ptr_array_unref (tobject->values);
    tobject->values = NULL;
  }
}

static void
thrift_bucket_class_init (ThriftBucketClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_bucket_read;
  struct_class->write = thrift_bucket_write;

  gobject_class->finalize = thrift_bucket_finalize;
  gobject_class->get_property = thrift_bucket_get_property;
  gobject_class->set_property = thrift_bucket_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_BUCKET_SEARCH_KEY_MIN,
     g_param_spec_int64 ("search_key_min",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_BUCKET_SEARCH_KEY_MAX,
     g_param_spec_int64 ("search_key_max",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_BUCKET_VALUES,
     g_param_spec_boxed ("values",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
thrift_bucket_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftBucketClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_bucket_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftBucket),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_bucket_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftBucketType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftBucketKeysProperties
{
  PROP_THRIFT_BUCKET_KEYS_0,
  PROP_THRIFT_BUCKET_KEYS_SEARCH_KEY_MIN,
  PROP_THRIFT_BUCKET_KEYS_SEARCH_KEY_MAX
};

/* reads a bucket_keys object */
static gint32
thrift_bucket_keys_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftBucketKeys * this_object = THRIFT_BUCKET_KEYS(object);
  gboolean isset_search_key_min = FALSE;
  gboolean isset_search_key_max = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->search_key_min, error)) < 0)
            return -1;
          xfer += ret;
          isset_search_key_min = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->search_key_max, error)) < 0)
            return -1;
          xfer += ret;
          isset_search_key_max = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_search_key_min)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_search_key_max)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
thrift_bucket_keys_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftBucketKeys * this_object = THRIFT_BUCKET_KEYS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BucketKeys", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "search_key_min", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->search_key_min, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "search_key_max", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->search_key_max, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_bucket_keys_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  ThriftBucketKeys *self = THRIFT_BUCKET_KEYS (object);

  switch (property_id)
  {
    case PROP_THRIFT_BUCKET_KEYS_SEARCH_KEY_MIN:
      self->search_key_min = g_value_get_int64 (value);
      break;

    case PROP_THRIFT_BUCKET_KEYS_SEARCH_KEY_MAX:
      self->search_key_max = g_value_get_int64 (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_bucket_keys_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  ThriftBucketKeys *self = THRIFT_BUCKET_KEYS (object);

  switch (property_id)
  {
    case PROP_THRIFT_BUCKET_KEYS_SEARCH_KEY_MIN:
      g_value_set_int64 (value, self->search_key_min);
      break;

    case PROP_THRIFT_BUCKET_KEYS_SEARCH_KEY_MAX:
      g_value_set_int64 (value, self->search_key_max);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_bucket_keys_instance_init (ThriftBucketKeys * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->search_key_min = 0;
  object->search_key_max = 0;
}

static void 
thrift_bucket_keys_finalize (GObject *object)
{
  ThriftBucketKeys *tobject = THRIFT_BUCKET_KEYS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
thrift_bucket_keys_class_init (ThriftBucketKeysClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_bucket_keys_read;
  struct_class->write = thrift_bucket_keys_write;

  gobject_class->finalize = thrift_bucket_keys_finalize;
  gobject_class->get_property = thrift_bucket_keys_get_property;
  gobject_class->set_property = thrift_bucket_keys_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_BUCKET_KEYS_SEARCH_KEY_MIN,
     g_param_spec_int64 ("search_key_min",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_BUCKET_KEYS_SEARCH_KEY_MAX,
     g_param_spec_int64 ("search_key_max",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
thrift_bucket_keys_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftBucketKeysClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_bucket_keys_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftBucketKeys),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_bucket_keys_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftBucketKeysType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftStorageExceptionProperties
{
  PROP_THRIFT_STORAGE_EXCEPTION_0,
  PROP_THRIFT_STORAGE_EXCEPTION_ERROR_CODE,
  PROP_THRIFT_STORAGE_EXCEPTION_ERROR_MESSAGE
};

/* reads a storage_exception object */
static gint32
thrift_storage_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftStorageException * this_object = THRIFT_STORAGE_EXCEPTION(object);
  gboolean isset_error_code = FALSE;
  gboolean isset_error_message = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->error_code, error)) < 0)
            return -1;
          xfer += ret;
          isset_error_code = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->error_message != NULL)
          {
            g_free(this_object->error_message);
            this_object->error_message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->error_message, error)) < 0)
            return -1;
          xfer += ret;
          isset_error_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_error_code)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_error_message)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
thrift_storage_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftStorageException * this_object = THRIFT_STORAGE_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "StorageException", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "error_code", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->error_code, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "error_message", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->error_message, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_storage_exception_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  ThriftStorageException *self = THRIFT_STORAGE_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_THRIFT_STORAGE_EXCEPTION_ERROR_CODE:
      self->error_code = g_value_get_int (value);
      break;

    case PROP_THRIFT_STORAGE_EXCEPTION_ERROR_MESSAGE:
      if (self->error_message != NULL)
        g_free (self->error_message);
      self->error_message = g_value_dup_string (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_storage_exception_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  ThriftStorageException *self = THRIFT_STORAGE_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_THRIFT_STORAGE_EXCEPTION_ERROR_CODE:
      g_value_set_int (value, self->error_code);
      break;

    case PROP_THRIFT_STORAGE_EXCEPTION_ERROR_MESSAGE:
      g_value_set_string (value, self->error_message);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_storage_exception_instance_init (ThriftStorageException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->error_code = 0;
  object->error_message = NULL;
}

static void 
thrift_storage_exception_finalize (GObject *object)
{
  ThriftStorageException *tobject = THRIFT_STORAGE_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->error_message != NULL)
  {
    g_free(tobject->error_message);
    tobject->error_message = NULL;
  }
}

static void
thrift_storage_exception_class_init (ThriftStorageExceptionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_storage_exception_read;
  struct_class->write = thrift_storage_exception_write;

  gobject_class->finalize = thrift_storage_exception_finalize;
  gobject_class->get_property = thrift_storage_exception_get_property;
  gobject_class->set_property = thrift_storage_exception_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_STORAGE_EXCEPTION_ERROR_CODE,
     g_param_spec_int ("error_code",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_STORAGE_EXCEPTION_ERROR_MESSAGE,
     g_param_spec_string ("error_message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
thrift_storage_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftStorageExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_storage_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftStorageException),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_storage_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftStorageExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define THRIFT_STORAGE_EXCEPTION_ERROR_DOMAIN "thrift_storage_exception_error_quark"
GQuark
thrift_storage_exception_error_quark (void)
{
  return g_quark_from_static_string (THRIFT_STORAGE_EXCEPTION_ERROR_DOMAIN);
}

/* constants */

enum _ThriftRpcFindClosestPeersArgsProperties
{
  PROP_THRIFT_RPC_FIND_CLOSEST_PEERS_ARGS_0,
  PROP_THRIFT_RPC_FIND_CLOSEST_PEERS_ARGS_KEY
};

/* reads a rpc_find_closest_peers_args object */
static gint32
thrift_rpc_find_closest_peers_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcFindClosestPeersArgs * this_object = THRIFT_RPC_FIND_CLOSEST_PEERS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->key = g_byte_array_new();
          g_byte_array_append (this_object->key, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_find_closest_peers_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcFindClosestPeersArgs * this_object = THRIFT_RPC_FIND_CLOSEST_PEERS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcFindClosestPeersArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->key ? ((GByteArray *) this_object->key)->data : NULL, this_object->key ? ((GByteArray *) this_object->key)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_rpc_find_closest_peers_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  ThriftRpcFindClosestPeersArgs *self = THRIFT_RPC_FIND_CLOSEST_PEERS_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_FIND_CLOSEST_PEERS_ARGS_KEY:
      if (self->key != NULL)
        g_byte_array_unref (self->key);
      self->key = g_value_dup_boxed (value);
      self->__isset_key = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_rpc_find_closest_peers_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  ThriftRpcFindClosestPeersArgs *self = THRIFT_RPC_FIND_CLOSEST_PEERS_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_FIND_CLOSEST_PEERS_ARGS_KEY:
      g_value_set_boxed (value, self->key);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_rpc_find_closest_peers_args_instance_init (ThriftRpcFindClosestPeersArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->__isset_key = FALSE;
}

static void 
thrift_rpc_find_closest_peers_args_finalize (GObject *object)
{
  ThriftRpcFindClosestPeersArgs *tobject = THRIFT_RPC_FIND_CLOSEST_PEERS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    thrift_string_free(tobject->key);
    tobject->key = NULL;
  }
}

static void
thrift_rpc_find_closest_peers_args_class_init (ThriftRpcFindClosestPeersArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_find_closest_peers_args_read;
  struct_class->write = thrift_rpc_find_closest_peers_args_write;

  gobject_class->finalize = thrift_rpc_find_closest_peers_args_finalize;
  gobject_class->get_property = thrift_rpc_find_closest_peers_args_get_property;
  gobject_class->set_property = thrift_rpc_find_closest_peers_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_FIND_CLOSEST_PEERS_ARGS_KEY,
     g_param_spec_boxed ("key",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
thrift_rpc_find_closest_peers_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcFindClosestPeersArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_find_closest_peers_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcFindClosestPeersArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_find_closest_peers_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcFindClosestPeersArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftRpcFindClosestPeersResultProperties
{
  PROP_THRIFT_RPC_FIND_CLOSEST_PEERS_RESULT_0,
  PROP_THRIFT_RPC_FIND_CLOSEST_PEERS_RESULT_SUCCESS
};

/* reads a rpc_find_closest_peers_result object */
static gint32
thrift_rpc_find_closest_peers_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcFindClosestPeersResult * this_object = THRIFT_RPC_FIND_CLOSEST_PEERS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ThriftPeer * _elem2 = NULL;
              if ( _elem2 != NULL)
              {
                g_object_unref (_elem2);
              }
              _elem2 = g_object_new (THRIFT_TYPE_PEER, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem2), protocol, error)) < 0)
              {
                g_object_unref (_elem2);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem2);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_find_closest_peers_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcFindClosestPeersResult * this_object = THRIFT_RPC_FIND_CLOSEST_PEERS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcFindClosestPeersResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i3;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i3 = 0; i3 < (this_object->success ? this_object->success->len : 0); i3++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i3))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_rpc_find_closest_peers_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  ThriftRpcFindClosestPeersResult *self = THRIFT_RPC_FIND_CLOSEST_PEERS_RESULT (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_FIND_CLOSEST_PEERS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_rpc_find_closest_peers_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  ThriftRpcFindClosestPeersResult *self = THRIFT_RPC_FIND_CLOSEST_PEERS_RESULT (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_FIND_CLOSEST_PEERS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_rpc_find_closest_peers_result_instance_init (ThriftRpcFindClosestPeersResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
}

static void 
thrift_rpc_find_closest_peers_result_finalize (GObject *object)
{
  ThriftRpcFindClosestPeersResult *tobject = THRIFT_RPC_FIND_CLOSEST_PEERS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
}

static void
thrift_rpc_find_closest_peers_result_class_init (ThriftRpcFindClosestPeersResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_find_closest_peers_result_read;
  struct_class->write = thrift_rpc_find_closest_peers_result_write;

  gobject_class->finalize = thrift_rpc_find_closest_peers_result_finalize;
  gobject_class->get_property = thrift_rpc_find_closest_peers_result_get_property;
  gobject_class->set_property = thrift_rpc_find_closest_peers_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_FIND_CLOSEST_PEERS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
thrift_rpc_find_closest_peers_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcFindClosestPeersResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_find_closest_peers_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcFindClosestPeersResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_find_closest_peers_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcFindClosestPeersResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftRpcFindKeyArgsProperties
{
  PROP_THRIFT_RPC_FIND_KEY_ARGS_0,
  PROP_THRIFT_RPC_FIND_KEY_ARGS_IDENT,
  PROP_THRIFT_RPC_FIND_KEY_ARGS_SEARCH_KEY
};

/* reads a rpc_find_key_args object */
static gint32
thrift_rpc_find_key_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcFindKeyArgs * this_object = THRIFT_RPC_FIND_KEY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->ident != NULL)
          {
            g_free(this_object->ident);
            this_object->ident = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ident, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ident = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->search_key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_search_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_find_key_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcFindKeyArgs * this_object = THRIFT_RPC_FIND_KEY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcFindKeyArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ident", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->ident, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "search_key", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->search_key, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_rpc_find_key_args_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  ThriftRpcFindKeyArgs *self = THRIFT_RPC_FIND_KEY_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_FIND_KEY_ARGS_IDENT:
      if (self->ident != NULL)
        g_free (self->ident);
      self->ident = g_value_dup_string (value);
      self->__isset_ident = TRUE;
      break;

    case PROP_THRIFT_RPC_FIND_KEY_ARGS_SEARCH_KEY:
      self->search_key = g_value_get_int64 (value);
      self->__isset_search_key = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_rpc_find_key_args_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  ThriftRpcFindKeyArgs *self = THRIFT_RPC_FIND_KEY_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_FIND_KEY_ARGS_IDENT:
      g_value_set_string (value, self->ident);
      break;

    case PROP_THRIFT_RPC_FIND_KEY_ARGS_SEARCH_KEY:
      g_value_set_int64 (value, self->search_key);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_rpc_find_key_args_instance_init (ThriftRpcFindKeyArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ident = NULL;
  object->__isset_ident = FALSE;
  object->search_key = 0;
  object->__isset_search_key = FALSE;
}

static void 
thrift_rpc_find_key_args_finalize (GObject *object)
{
  ThriftRpcFindKeyArgs *tobject = THRIFT_RPC_FIND_KEY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ident != NULL)
  {
    g_free(tobject->ident);
    tobject->ident = NULL;
  }
}

static void
thrift_rpc_find_key_args_class_init (ThriftRpcFindKeyArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_find_key_args_read;
  struct_class->write = thrift_rpc_find_key_args_write;

  gobject_class->finalize = thrift_rpc_find_key_args_finalize;
  gobject_class->get_property = thrift_rpc_find_key_args_get_property;
  gobject_class->set_property = thrift_rpc_find_key_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_FIND_KEY_ARGS_IDENT,
     g_param_spec_string ("ident",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_FIND_KEY_ARGS_SEARCH_KEY,
     g_param_spec_int64 ("search_key",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
thrift_rpc_find_key_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcFindKeyArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_find_key_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcFindKeyArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_find_key_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcFindKeyArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftRpcFindKeyResultProperties
{
  PROP_THRIFT_RPC_FIND_KEY_RESULT_0,
  PROP_THRIFT_RPC_FIND_KEY_RESULT_SUCCESS,
  PROP_THRIFT_RPC_FIND_KEY_RESULT_ERR
};

/* reads a rpc_find_key_result object */
static gint32
thrift_rpc_find_key_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcFindKeyResult * this_object = THRIFT_RPC_FIND_KEY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->success = g_byte_array_new();
          g_byte_array_append (this_object->success, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->err != NULL)
          {
            g_object_unref (this_object->err);
          }
          this_object->err = g_object_new (THRIFT_TYPE_STORAGE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->err), protocol, error)) < 0)
          {
            g_object_unref (this_object->err);
            this_object->err = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_err = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_find_key_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcFindKeyResult * this_object = THRIFT_RPC_FIND_KEY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcFindKeyResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->success ? ((GByteArray *) this_object->success)->data : NULL, this_object->success ? ((GByteArray *) this_object->success)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_err == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "err", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->err), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_rpc_find_key_result_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  ThriftRpcFindKeyResult *self = THRIFT_RPC_FIND_KEY_RESULT (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_FIND_KEY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_byte_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_THRIFT_RPC_FIND_KEY_RESULT_ERR:
      if (self->err != NULL)
        g_object_unref (self->err);
      self->err = g_value_dup_object (value);
      self->__isset_err = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_rpc_find_key_result_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  ThriftRpcFindKeyResult *self = THRIFT_RPC_FIND_KEY_RESULT (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_FIND_KEY_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_THRIFT_RPC_FIND_KEY_RESULT_ERR:
      g_value_set_object (value, self->err);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_rpc_find_key_result_instance_init (ThriftRpcFindKeyResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->err = NULL;
  object->__isset_err = FALSE;
}

static void 
thrift_rpc_find_key_result_finalize (GObject *object)
{
  ThriftRpcFindKeyResult *tobject = THRIFT_RPC_FIND_KEY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    thrift_string_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->err != NULL)
  {
    g_object_unref(tobject->err);
    tobject->err = NULL;
  }
}

static void
thrift_rpc_find_key_result_class_init (ThriftRpcFindKeyResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_find_key_result_read;
  struct_class->write = thrift_rpc_find_key_result_write;

  gobject_class->finalize = thrift_rpc_find_key_result_finalize;
  gobject_class->get_property = thrift_rpc_find_key_result_get_property;
  gobject_class->set_property = thrift_rpc_find_key_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_FIND_KEY_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_FIND_KEY_RESULT_ERR,
     g_param_spec_object ("err",
                         NULL,
                         NULL,
                         THRIFT_TYPE_STORAGE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
thrift_rpc_find_key_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcFindKeyResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_find_key_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcFindKeyResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_find_key_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcFindKeyResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftRpcGetBucketKeysArgsProperties
{
  PROP_THRIFT_RPC_GET_BUCKET_KEYS_ARGS_0,
  PROP_THRIFT_RPC_GET_BUCKET_KEYS_ARGS_KEY
};

/* reads a rpc_get_bucket_keys_args object */
static gint32
thrift_rpc_get_bucket_keys_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcGetBucketKeysArgs * this_object = THRIFT_RPC_GET_BUCKET_KEYS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->key = g_byte_array_new();
          g_byte_array_append (this_object->key, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_get_bucket_keys_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcGetBucketKeysArgs * this_object = THRIFT_RPC_GET_BUCKET_KEYS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcGetBucketKeysArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->key ? ((GByteArray *) this_object->key)->data : NULL, this_object->key ? ((GByteArray *) this_object->key)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_rpc_get_bucket_keys_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  ThriftRpcGetBucketKeysArgs *self = THRIFT_RPC_GET_BUCKET_KEYS_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_GET_BUCKET_KEYS_ARGS_KEY:
      if (self->key != NULL)
        g_byte_array_unref (self->key);
      self->key = g_value_dup_boxed (value);
      self->__isset_key = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_rpc_get_bucket_keys_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  ThriftRpcGetBucketKeysArgs *self = THRIFT_RPC_GET_BUCKET_KEYS_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_GET_BUCKET_KEYS_ARGS_KEY:
      g_value_set_boxed (value, self->key);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_rpc_get_bucket_keys_args_instance_init (ThriftRpcGetBucketKeysArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->__isset_key = FALSE;
}

static void 
thrift_rpc_get_bucket_keys_args_finalize (GObject *object)
{
  ThriftRpcGetBucketKeysArgs *tobject = THRIFT_RPC_GET_BUCKET_KEYS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    thrift_string_free(tobject->key);
    tobject->key = NULL;
  }
}

static void
thrift_rpc_get_bucket_keys_args_class_init (ThriftRpcGetBucketKeysArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_get_bucket_keys_args_read;
  struct_class->write = thrift_rpc_get_bucket_keys_args_write;

  gobject_class->finalize = thrift_rpc_get_bucket_keys_args_finalize;
  gobject_class->get_property = thrift_rpc_get_bucket_keys_args_get_property;
  gobject_class->set_property = thrift_rpc_get_bucket_keys_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_GET_BUCKET_KEYS_ARGS_KEY,
     g_param_spec_boxed ("key",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
thrift_rpc_get_bucket_keys_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcGetBucketKeysArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_get_bucket_keys_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcGetBucketKeysArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_get_bucket_keys_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcGetBucketKeysArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftRpcGetBucketKeysResultProperties
{
  PROP_THRIFT_RPC_GET_BUCKET_KEYS_RESULT_0,
  PROP_THRIFT_RPC_GET_BUCKET_KEYS_RESULT_SUCCESS,
  PROP_THRIFT_RPC_GET_BUCKET_KEYS_RESULT_ERR
};

/* reads a rpc_get_bucket_keys_result object */
static gint32
thrift_rpc_get_bucket_keys_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcGetBucketKeysResult * this_object = THRIFT_RPC_GET_BUCKET_KEYS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->err != NULL)
          {
            g_object_unref (this_object->err);
          }
          this_object->err = g_object_new (THRIFT_TYPE_STORAGE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->err), protocol, error)) < 0)
          {
            g_object_unref (this_object->err);
            this_object->err = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_err = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_get_bucket_keys_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcGetBucketKeysResult * this_object = THRIFT_RPC_GET_BUCKET_KEYS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcGetBucketKeysResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_err == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "err", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->err), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_rpc_get_bucket_keys_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  ThriftRpcGetBucketKeysResult *self = THRIFT_RPC_GET_BUCKET_KEYS_RESULT (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_GET_BUCKET_KEYS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_THRIFT_RPC_GET_BUCKET_KEYS_RESULT_ERR:
      if (self->err != NULL)
        g_object_unref (self->err);
      self->err = g_value_dup_object (value);
      self->__isset_err = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_rpc_get_bucket_keys_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  ThriftRpcGetBucketKeysResult *self = THRIFT_RPC_GET_BUCKET_KEYS_RESULT (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_GET_BUCKET_KEYS_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_THRIFT_RPC_GET_BUCKET_KEYS_RESULT_ERR:
      g_value_set_object (value, self->err);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_rpc_get_bucket_keys_result_instance_init (ThriftRpcGetBucketKeysResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (THRIFT_TYPE_BUCKET_KEYS, NULL);
  object->__isset_success = FALSE;
  object->err = NULL;
  object->__isset_err = FALSE;
}

static void 
thrift_rpc_get_bucket_keys_result_finalize (GObject *object)
{
  ThriftRpcGetBucketKeysResult *tobject = THRIFT_RPC_GET_BUCKET_KEYS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->err != NULL)
  {
    g_object_unref(tobject->err);
    tobject->err = NULL;
  }
}

static void
thrift_rpc_get_bucket_keys_result_class_init (ThriftRpcGetBucketKeysResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_get_bucket_keys_result_read;
  struct_class->write = thrift_rpc_get_bucket_keys_result_write;

  gobject_class->finalize = thrift_rpc_get_bucket_keys_result_finalize;
  gobject_class->get_property = thrift_rpc_get_bucket_keys_result_get_property;
  gobject_class->set_property = thrift_rpc_get_bucket_keys_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_GET_BUCKET_KEYS_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         THRIFT_TYPE_BUCKET_KEYS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_GET_BUCKET_KEYS_RESULT_ERR,
     g_param_spec_object ("err",
                         NULL,
                         NULL,
                         THRIFT_TYPE_STORAGE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
thrift_rpc_get_bucket_keys_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcGetBucketKeysResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_get_bucket_keys_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcGetBucketKeysResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_get_bucket_keys_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcGetBucketKeysResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftRpcPutArgsProperties
{
  PROP_THRIFT_RPC_PUT_ARGS_0,
  PROP_THRIFT_RPC_PUT_ARGS_KEY,
  PROP_THRIFT_RPC_PUT_ARGS_VALUE
};

/* reads a rpc_put_args object */
static gint32
thrift_rpc_put_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcPutArgs * this_object = THRIFT_RPC_PUT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->key = g_byte_array_new();
          g_byte_array_append (this_object->key, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->value = g_byte_array_new();
          g_byte_array_append (this_object->value, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_put_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcPutArgs * this_object = THRIFT_RPC_PUT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcPutArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->key ? ((GByteArray *) this_object->key)->data : NULL, this_object->key ? ((GByteArray *) this_object->key)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->value ? ((GByteArray *) this_object->value)->data : NULL, this_object->value ? ((GByteArray *) this_object->value)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_rpc_put_args_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  ThriftRpcPutArgs *self = THRIFT_RPC_PUT_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_PUT_ARGS_KEY:
      if (self->key != NULL)
        g_byte_array_unref (self->key);
      self->key = g_value_dup_boxed (value);
      self->__isset_key = TRUE;
      break;

    case PROP_THRIFT_RPC_PUT_ARGS_VALUE:
      if (self->value != NULL)
        g_byte_array_unref (self->value);
      self->value = g_value_dup_boxed (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_rpc_put_args_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  ThriftRpcPutArgs *self = THRIFT_RPC_PUT_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_PUT_ARGS_KEY:
      g_value_set_boxed (value, self->key);
      break;

    case PROP_THRIFT_RPC_PUT_ARGS_VALUE:
      g_value_set_boxed (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_rpc_put_args_instance_init (ThriftRpcPutArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->__isset_key = FALSE;
  object->value = NULL;
  object->__isset_value = FALSE;
}

static void 
thrift_rpc_put_args_finalize (GObject *object)
{
  ThriftRpcPutArgs *tobject = THRIFT_RPC_PUT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    thrift_string_free(tobject->key);
    tobject->key = NULL;
  }
  if (tobject->value != NULL)
  {
    thrift_string_free(tobject->value);
    tobject->value = NULL;
  }
}

static void
thrift_rpc_put_args_class_init (ThriftRpcPutArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_put_args_read;
  struct_class->write = thrift_rpc_put_args_write;

  gobject_class->finalize = thrift_rpc_put_args_finalize;
  gobject_class->get_property = thrift_rpc_put_args_get_property;
  gobject_class->set_property = thrift_rpc_put_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_PUT_ARGS_KEY,
     g_param_spec_boxed ("key",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_PUT_ARGS_VALUE,
     g_param_spec_boxed ("value",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
thrift_rpc_put_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcPutArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_put_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcPutArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_put_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcPutArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a rpc_put_result object */
static gint32
thrift_rpc_put_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcPutResult * this_object = THRIFT_RPC_PUT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_put_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcPutResult * this_object = THRIFT_RPC_PUT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcPutResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
thrift_rpc_put_result_instance_init (ThriftRpcPutResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
thrift_rpc_put_result_finalize (GObject *object)
{
  ThriftRpcPutResult *tobject = THRIFT_RPC_PUT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
thrift_rpc_put_result_class_init (ThriftRpcPutResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_put_result_read;
  struct_class->write = thrift_rpc_put_result_write;

  gobject_class->finalize = thrift_rpc_put_result_finalize;
}

GType
thrift_rpc_put_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcPutResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_put_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcPutResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_put_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcPutResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftRpcPutLatestArgsProperties
{
  PROP_THRIFT_RPC_PUT_LATEST_ARGS_0,
  PROP_THRIFT_RPC_PUT_LATEST_ARGS_KEY,
  PROP_THRIFT_RPC_PUT_LATEST_ARGS_SEARCH_KEY,
  PROP_THRIFT_RPC_PUT_LATEST_ARGS_VALUE
};

/* reads a rpc_put_latest_args object */
static gint32
thrift_rpc_put_latest_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcPutLatestArgs * this_object = THRIFT_RPC_PUT_LATEST_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->key = g_byte_array_new();
          g_byte_array_append (this_object->key, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->search_key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_search_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->value = g_byte_array_new();
          g_byte_array_append (this_object->value, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_put_latest_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcPutLatestArgs * this_object = THRIFT_RPC_PUT_LATEST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcPutLatestArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->key ? ((GByteArray *) this_object->key)->data : NULL, this_object->key ? ((GByteArray *) this_object->key)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "search_key", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->search_key, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->value ? ((GByteArray *) this_object->value)->data : NULL, this_object->value ? ((GByteArray *) this_object->value)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_rpc_put_latest_args_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  ThriftRpcPutLatestArgs *self = THRIFT_RPC_PUT_LATEST_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_PUT_LATEST_ARGS_KEY:
      if (self->key != NULL)
        g_byte_array_unref (self->key);
      self->key = g_value_dup_boxed (value);
      self->__isset_key = TRUE;
      break;

    case PROP_THRIFT_RPC_PUT_LATEST_ARGS_SEARCH_KEY:
      self->search_key = g_value_get_int64 (value);
      self->__isset_search_key = TRUE;
      break;

    case PROP_THRIFT_RPC_PUT_LATEST_ARGS_VALUE:
      if (self->value != NULL)
        g_byte_array_unref (self->value);
      self->value = g_value_dup_boxed (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_rpc_put_latest_args_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  ThriftRpcPutLatestArgs *self = THRIFT_RPC_PUT_LATEST_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_PUT_LATEST_ARGS_KEY:
      g_value_set_boxed (value, self->key);
      break;

    case PROP_THRIFT_RPC_PUT_LATEST_ARGS_SEARCH_KEY:
      g_value_set_int64 (value, self->search_key);
      break;

    case PROP_THRIFT_RPC_PUT_LATEST_ARGS_VALUE:
      g_value_set_boxed (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_rpc_put_latest_args_instance_init (ThriftRpcPutLatestArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->__isset_key = FALSE;
  object->search_key = 0;
  object->__isset_search_key = FALSE;
  object->value = NULL;
  object->__isset_value = FALSE;
}

static void 
thrift_rpc_put_latest_args_finalize (GObject *object)
{
  ThriftRpcPutLatestArgs *tobject = THRIFT_RPC_PUT_LATEST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    thrift_string_free(tobject->key);
    tobject->key = NULL;
  }
  if (tobject->value != NULL)
  {
    thrift_string_free(tobject->value);
    tobject->value = NULL;
  }
}

static void
thrift_rpc_put_latest_args_class_init (ThriftRpcPutLatestArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_put_latest_args_read;
  struct_class->write = thrift_rpc_put_latest_args_write;

  gobject_class->finalize = thrift_rpc_put_latest_args_finalize;
  gobject_class->get_property = thrift_rpc_put_latest_args_get_property;
  gobject_class->set_property = thrift_rpc_put_latest_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_PUT_LATEST_ARGS_KEY,
     g_param_spec_boxed ("key",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_PUT_LATEST_ARGS_SEARCH_KEY,
     g_param_spec_int64 ("search_key",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_PUT_LATEST_ARGS_VALUE,
     g_param_spec_boxed ("value",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
thrift_rpc_put_latest_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcPutLatestArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_put_latest_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcPutLatestArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_put_latest_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcPutLatestArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a rpc_put_latest_result object */
static gint32
thrift_rpc_put_latest_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcPutLatestResult * this_object = THRIFT_RPC_PUT_LATEST_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_put_latest_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcPutLatestResult * this_object = THRIFT_RPC_PUT_LATEST_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcPutLatestResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
thrift_rpc_put_latest_result_instance_init (ThriftRpcPutLatestResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
thrift_rpc_put_latest_result_finalize (GObject *object)
{
  ThriftRpcPutLatestResult *tobject = THRIFT_RPC_PUT_LATEST_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
thrift_rpc_put_latest_result_class_init (ThriftRpcPutLatestResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_put_latest_result_read;
  struct_class->write = thrift_rpc_put_latest_result_write;

  gobject_class->finalize = thrift_rpc_put_latest_result_finalize;
}

GType
thrift_rpc_put_latest_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcPutLatestResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_put_latest_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcPutLatestResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_put_latest_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcPutLatestResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftRpcAddArgsProperties
{
  PROP_THRIFT_RPC_ADD_ARGS_0,
  PROP_THRIFT_RPC_ADD_ARGS_KEY,
  PROP_THRIFT_RPC_ADD_ARGS_VALUE,
  PROP_THRIFT_RPC_ADD_ARGS_NAME,
  PROP_THRIFT_RPC_ADD_ARGS_SEARCH_KEY_MIN,
  PROP_THRIFT_RPC_ADD_ARGS_SEARCH_KEY_MAX
};

/* reads a rpc_add_args object */
static gint32
thrift_rpc_add_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcAddArgs * this_object = THRIFT_RPC_ADD_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->key = g_byte_array_new();
          g_byte_array_append (this_object->key, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->search_key_min, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_search_key_min = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->search_key_max, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_search_key_max = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_add_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcAddArgs * this_object = THRIFT_RPC_ADD_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcAddArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->key ? ((GByteArray *) this_object->key)->data : NULL, this_object->key ? ((GByteArray *) this_object->key)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "search_key_min", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->search_key_min, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "search_key_max", T_I64, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->search_key_max, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_rpc_add_args_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  ThriftRpcAddArgs *self = THRIFT_RPC_ADD_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_ADD_ARGS_KEY:
      if (self->key != NULL)
        g_byte_array_unref (self->key);
      self->key = g_value_dup_boxed (value);
      self->__isset_key = TRUE;
      break;

    case PROP_THRIFT_RPC_ADD_ARGS_VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    case PROP_THRIFT_RPC_ADD_ARGS_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_THRIFT_RPC_ADD_ARGS_SEARCH_KEY_MIN:
      self->search_key_min = g_value_get_int64 (value);
      self->__isset_search_key_min = TRUE;
      break;

    case PROP_THRIFT_RPC_ADD_ARGS_SEARCH_KEY_MAX:
      self->search_key_max = g_value_get_int64 (value);
      self->__isset_search_key_max = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_rpc_add_args_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  ThriftRpcAddArgs *self = THRIFT_RPC_ADD_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_ADD_ARGS_KEY:
      g_value_set_boxed (value, self->key);
      break;

    case PROP_THRIFT_RPC_ADD_ARGS_VALUE:
      g_value_set_object (value, self->value);
      break;

    case PROP_THRIFT_RPC_ADD_ARGS_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_THRIFT_RPC_ADD_ARGS_SEARCH_KEY_MIN:
      g_value_set_int64 (value, self->search_key_min);
      break;

    case PROP_THRIFT_RPC_ADD_ARGS_SEARCH_KEY_MAX:
      g_value_set_int64 (value, self->search_key_max);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_rpc_add_args_instance_init (ThriftRpcAddArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->__isset_key = FALSE;
  object->value = g_object_new (THRIFT_TYPE_BUCKET_VALUE, NULL);
  object->__isset_value = FALSE;
  object->name = NULL;
  object->__isset_name = FALSE;
  object->search_key_min = 0;
  object->__isset_search_key_min = FALSE;
  object->search_key_max = 0;
  object->__isset_search_key_max = FALSE;
}

static void 
thrift_rpc_add_args_finalize (GObject *object)
{
  ThriftRpcAddArgs *tobject = THRIFT_RPC_ADD_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    thrift_string_free(tobject->key);
    tobject->key = NULL;
  }
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
}

static void
thrift_rpc_add_args_class_init (ThriftRpcAddArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_add_args_read;
  struct_class->write = thrift_rpc_add_args_write;

  gobject_class->finalize = thrift_rpc_add_args_finalize;
  gobject_class->get_property = thrift_rpc_add_args_get_property;
  gobject_class->set_property = thrift_rpc_add_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_ADD_ARGS_KEY,
     g_param_spec_boxed ("key",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_ADD_ARGS_VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         THRIFT_TYPE_BUCKET_VALUE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_ADD_ARGS_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_ADD_ARGS_SEARCH_KEY_MIN,
     g_param_spec_int64 ("search_key_min",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_ADD_ARGS_SEARCH_KEY_MAX,
     g_param_spec_int64 ("search_key_max",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
thrift_rpc_add_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcAddArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_add_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcAddArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_add_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcAddArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftRpcAddResultProperties
{
  PROP_THRIFT_RPC_ADD_RESULT_0,
  PROP_THRIFT_RPC_ADD_RESULT_ERR
};

/* reads a rpc_add_result object */
static gint32
thrift_rpc_add_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcAddResult * this_object = THRIFT_RPC_ADD_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->err != NULL)
          {
            g_object_unref (this_object->err);
          }
          this_object->err = g_object_new (THRIFT_TYPE_STORAGE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->err), protocol, error)) < 0)
          {
            g_object_unref (this_object->err);
            this_object->err = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_err = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_add_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcAddResult * this_object = THRIFT_RPC_ADD_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcAddResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_err == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "err", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->err), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_rpc_add_result_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  ThriftRpcAddResult *self = THRIFT_RPC_ADD_RESULT (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_ADD_RESULT_ERR:
      if (self->err != NULL)
        g_object_unref (self->err);
      self->err = g_value_dup_object (value);
      self->__isset_err = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_rpc_add_result_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  ThriftRpcAddResult *self = THRIFT_RPC_ADD_RESULT (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_ADD_RESULT_ERR:
      g_value_set_object (value, self->err);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_rpc_add_result_instance_init (ThriftRpcAddResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->err = NULL;
  object->__isset_err = FALSE;
}

static void 
thrift_rpc_add_result_finalize (GObject *object)
{
  ThriftRpcAddResult *tobject = THRIFT_RPC_ADD_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->err != NULL)
  {
    g_object_unref(tobject->err);
    tobject->err = NULL;
  }
}

static void
thrift_rpc_add_result_class_init (ThriftRpcAddResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_add_result_read;
  struct_class->write = thrift_rpc_add_result_write;

  gobject_class->finalize = thrift_rpc_add_result_finalize;
  gobject_class->get_property = thrift_rpc_add_result_get_property;
  gobject_class->set_property = thrift_rpc_add_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_ADD_RESULT_ERR,
     g_param_spec_object ("err",
                         NULL,
                         NULL,
                         THRIFT_TYPE_STORAGE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
thrift_rpc_add_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcAddResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_add_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcAddResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_add_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcAddResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftRpcGetArgsProperties
{
  PROP_THRIFT_RPC_GET_ARGS_0,
  PROP_THRIFT_RPC_GET_ARGS_KEY
};

/* reads a rpc_get_args object */
static gint32
thrift_rpc_get_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcGetArgs * this_object = THRIFT_RPC_GET_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->key = g_byte_array_new();
          g_byte_array_append (this_object->key, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_get_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcGetArgs * this_object = THRIFT_RPC_GET_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcGetArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->key ? ((GByteArray *) this_object->key)->data : NULL, this_object->key ? ((GByteArray *) this_object->key)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_rpc_get_args_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  ThriftRpcGetArgs *self = THRIFT_RPC_GET_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_GET_ARGS_KEY:
      if (self->key != NULL)
        g_byte_array_unref (self->key);
      self->key = g_value_dup_boxed (value);
      self->__isset_key = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_rpc_get_args_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  ThriftRpcGetArgs *self = THRIFT_RPC_GET_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_GET_ARGS_KEY:
      g_value_set_boxed (value, self->key);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_rpc_get_args_instance_init (ThriftRpcGetArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->__isset_key = FALSE;
}

static void 
thrift_rpc_get_args_finalize (GObject *object)
{
  ThriftRpcGetArgs *tobject = THRIFT_RPC_GET_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    thrift_string_free(tobject->key);
    tobject->key = NULL;
  }
}

static void
thrift_rpc_get_args_class_init (ThriftRpcGetArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_get_args_read;
  struct_class->write = thrift_rpc_get_args_write;

  gobject_class->finalize = thrift_rpc_get_args_finalize;
  gobject_class->get_property = thrift_rpc_get_args_get_property;
  gobject_class->set_property = thrift_rpc_get_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_GET_ARGS_KEY,
     g_param_spec_boxed ("key",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
thrift_rpc_get_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcGetArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_get_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcGetArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_get_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcGetArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftRpcGetResultProperties
{
  PROP_THRIFT_RPC_GET_RESULT_0,
  PROP_THRIFT_RPC_GET_RESULT_SUCCESS,
  PROP_THRIFT_RPC_GET_RESULT_ERR
};

/* reads a rpc_get_result object */
static gint32
thrift_rpc_get_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcGetResult * this_object = THRIFT_RPC_GET_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->success = g_byte_array_new();
          g_byte_array_append (this_object->success, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->err != NULL)
          {
            g_object_unref (this_object->err);
          }
          this_object->err = g_object_new (THRIFT_TYPE_STORAGE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->err), protocol, error)) < 0)
          {
            g_object_unref (this_object->err);
            this_object->err = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_err = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_get_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcGetResult * this_object = THRIFT_RPC_GET_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcGetResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->success ? ((GByteArray *) this_object->success)->data : NULL, this_object->success ? ((GByteArray *) this_object->success)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_err == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "err", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->err), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_rpc_get_result_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  ThriftRpcGetResult *self = THRIFT_RPC_GET_RESULT (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_GET_RESULT_SUCCESS:
      if (self->success != NULL)
        g_byte_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_THRIFT_RPC_GET_RESULT_ERR:
      if (self->err != NULL)
        g_object_unref (self->err);
      self->err = g_value_dup_object (value);
      self->__isset_err = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_rpc_get_result_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  ThriftRpcGetResult *self = THRIFT_RPC_GET_RESULT (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_GET_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_THRIFT_RPC_GET_RESULT_ERR:
      g_value_set_object (value, self->err);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_rpc_get_result_instance_init (ThriftRpcGetResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->err = NULL;
  object->__isset_err = FALSE;
}

static void 
thrift_rpc_get_result_finalize (GObject *object)
{
  ThriftRpcGetResult *tobject = THRIFT_RPC_GET_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    thrift_string_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->err != NULL)
  {
    g_object_unref(tobject->err);
    tobject->err = NULL;
  }
}

static void
thrift_rpc_get_result_class_init (ThriftRpcGetResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_get_result_read;
  struct_class->write = thrift_rpc_get_result_write;

  gobject_class->finalize = thrift_rpc_get_result_finalize;
  gobject_class->get_property = thrift_rpc_get_result_get_property;
  gobject_class->set_property = thrift_rpc_get_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_GET_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_GET_RESULT_ERR,
     g_param_spec_object ("err",
                         NULL,
                         NULL,
                         THRIFT_TYPE_STORAGE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
thrift_rpc_get_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcGetResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_get_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcGetResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_get_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcGetResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftRpcGetLatestMaxArgsProperties
{
  PROP_THRIFT_RPC_GET_LATEST_MAX_ARGS_0,
  PROP_THRIFT_RPC_GET_LATEST_MAX_ARGS_NAME,
  PROP_THRIFT_RPC_GET_LATEST_MAX_ARGS_SEARCH_KEY_MAX
};

/* reads a rpc_get_latest_max_args object */
static gint32
thrift_rpc_get_latest_max_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcGetLatestMaxArgs * this_object = THRIFT_RPC_GET_LATEST_MAX_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->search_key_max, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_search_key_max = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_get_latest_max_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcGetLatestMaxArgs * this_object = THRIFT_RPC_GET_LATEST_MAX_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcGetLatestMaxArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "search_key_max", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->search_key_max, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_rpc_get_latest_max_args_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  ThriftRpcGetLatestMaxArgs *self = THRIFT_RPC_GET_LATEST_MAX_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_GET_LATEST_MAX_ARGS_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_THRIFT_RPC_GET_LATEST_MAX_ARGS_SEARCH_KEY_MAX:
      self->search_key_max = g_value_get_int64 (value);
      self->__isset_search_key_max = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_rpc_get_latest_max_args_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  ThriftRpcGetLatestMaxArgs *self = THRIFT_RPC_GET_LATEST_MAX_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_GET_LATEST_MAX_ARGS_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_THRIFT_RPC_GET_LATEST_MAX_ARGS_SEARCH_KEY_MAX:
      g_value_set_int64 (value, self->search_key_max);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_rpc_get_latest_max_args_instance_init (ThriftRpcGetLatestMaxArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->search_key_max = 0;
  object->__isset_search_key_max = FALSE;
}

static void 
thrift_rpc_get_latest_max_args_finalize (GObject *object)
{
  ThriftRpcGetLatestMaxArgs *tobject = THRIFT_RPC_GET_LATEST_MAX_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
}

static void
thrift_rpc_get_latest_max_args_class_init (ThriftRpcGetLatestMaxArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_get_latest_max_args_read;
  struct_class->write = thrift_rpc_get_latest_max_args_write;

  gobject_class->finalize = thrift_rpc_get_latest_max_args_finalize;
  gobject_class->get_property = thrift_rpc_get_latest_max_args_get_property;
  gobject_class->set_property = thrift_rpc_get_latest_max_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_GET_LATEST_MAX_ARGS_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_GET_LATEST_MAX_ARGS_SEARCH_KEY_MAX,
     g_param_spec_int64 ("search_key_max",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
thrift_rpc_get_latest_max_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcGetLatestMaxArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_get_latest_max_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcGetLatestMaxArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_get_latest_max_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcGetLatestMaxArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftRpcGetLatestMaxResultProperties
{
  PROP_THRIFT_RPC_GET_LATEST_MAX_RESULT_0,
  PROP_THRIFT_RPC_GET_LATEST_MAX_RESULT_SUCCESS,
  PROP_THRIFT_RPC_GET_LATEST_MAX_RESULT_ERR
};

/* reads a rpc_get_latest_max_result object */
static gint32
thrift_rpc_get_latest_max_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcGetLatestMaxResult * this_object = THRIFT_RPC_GET_LATEST_MAX_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->err != NULL)
          {
            g_object_unref (this_object->err);
          }
          this_object->err = g_object_new (THRIFT_TYPE_STORAGE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->err), protocol, error)) < 0)
          {
            g_object_unref (this_object->err);
            this_object->err = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_err = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_get_latest_max_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcGetLatestMaxResult * this_object = THRIFT_RPC_GET_LATEST_MAX_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcGetLatestMaxResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_err == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "err", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->err), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_rpc_get_latest_max_result_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  ThriftRpcGetLatestMaxResult *self = THRIFT_RPC_GET_LATEST_MAX_RESULT (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_GET_LATEST_MAX_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_THRIFT_RPC_GET_LATEST_MAX_RESULT_ERR:
      if (self->err != NULL)
        g_object_unref (self->err);
      self->err = g_value_dup_object (value);
      self->__isset_err = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_rpc_get_latest_max_result_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  ThriftRpcGetLatestMaxResult *self = THRIFT_RPC_GET_LATEST_MAX_RESULT (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_GET_LATEST_MAX_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_THRIFT_RPC_GET_LATEST_MAX_RESULT_ERR:
      g_value_set_object (value, self->err);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_rpc_get_latest_max_result_instance_init (ThriftRpcGetLatestMaxResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (THRIFT_TYPE_BUCKET_VALUE, NULL);
  object->__isset_success = FALSE;
  object->err = NULL;
  object->__isset_err = FALSE;
}

static void 
thrift_rpc_get_latest_max_result_finalize (GObject *object)
{
  ThriftRpcGetLatestMaxResult *tobject = THRIFT_RPC_GET_LATEST_MAX_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->err != NULL)
  {
    g_object_unref(tobject->err);
    tobject->err = NULL;
  }
}

static void
thrift_rpc_get_latest_max_result_class_init (ThriftRpcGetLatestMaxResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_get_latest_max_result_read;
  struct_class->write = thrift_rpc_get_latest_max_result_write;

  gobject_class->finalize = thrift_rpc_get_latest_max_result_finalize;
  gobject_class->get_property = thrift_rpc_get_latest_max_result_get_property;
  gobject_class->set_property = thrift_rpc_get_latest_max_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_GET_LATEST_MAX_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         THRIFT_TYPE_BUCKET_VALUE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_GET_LATEST_MAX_RESULT_ERR,
     g_param_spec_object ("err",
                         NULL,
                         NULL,
                         THRIFT_TYPE_STORAGE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
thrift_rpc_get_latest_max_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcGetLatestMaxResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_get_latest_max_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcGetLatestMaxResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_get_latest_max_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcGetLatestMaxResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftRpcGetRangeArgsProperties
{
  PROP_THRIFT_RPC_GET_RANGE_ARGS_0,
  PROP_THRIFT_RPC_GET_RANGE_ARGS_NAME,
  PROP_THRIFT_RPC_GET_RANGE_ARGS_SEARCH_KEY_MIN,
  PROP_THRIFT_RPC_GET_RANGE_ARGS_SEARCH_KEY_MAX
};

/* reads a rpc_get_range_args object */
static gint32
thrift_rpc_get_range_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcGetRangeArgs * this_object = THRIFT_RPC_GET_RANGE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->search_key_min, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_search_key_min = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->search_key_max, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_search_key_max = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_get_range_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcGetRangeArgs * this_object = THRIFT_RPC_GET_RANGE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcGetRangeArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "search_key_min", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->search_key_min, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "search_key_max", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->search_key_max, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_rpc_get_range_args_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  ThriftRpcGetRangeArgs *self = THRIFT_RPC_GET_RANGE_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_GET_RANGE_ARGS_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_THRIFT_RPC_GET_RANGE_ARGS_SEARCH_KEY_MIN:
      self->search_key_min = g_value_get_int64 (value);
      self->__isset_search_key_min = TRUE;
      break;

    case PROP_THRIFT_RPC_GET_RANGE_ARGS_SEARCH_KEY_MAX:
      self->search_key_max = g_value_get_int64 (value);
      self->__isset_search_key_max = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_rpc_get_range_args_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  ThriftRpcGetRangeArgs *self = THRIFT_RPC_GET_RANGE_ARGS (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_GET_RANGE_ARGS_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_THRIFT_RPC_GET_RANGE_ARGS_SEARCH_KEY_MIN:
      g_value_set_int64 (value, self->search_key_min);
      break;

    case PROP_THRIFT_RPC_GET_RANGE_ARGS_SEARCH_KEY_MAX:
      g_value_set_int64 (value, self->search_key_max);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_rpc_get_range_args_instance_init (ThriftRpcGetRangeArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->name = NULL;
  object->__isset_name = FALSE;
  object->search_key_min = 0;
  object->__isset_search_key_min = FALSE;
  object->search_key_max = 0;
  object->__isset_search_key_max = FALSE;
}

static void 
thrift_rpc_get_range_args_finalize (GObject *object)
{
  ThriftRpcGetRangeArgs *tobject = THRIFT_RPC_GET_RANGE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
}

static void
thrift_rpc_get_range_args_class_init (ThriftRpcGetRangeArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_get_range_args_read;
  struct_class->write = thrift_rpc_get_range_args_write;

  gobject_class->finalize = thrift_rpc_get_range_args_finalize;
  gobject_class->get_property = thrift_rpc_get_range_args_get_property;
  gobject_class->set_property = thrift_rpc_get_range_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_GET_RANGE_ARGS_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_GET_RANGE_ARGS_SEARCH_KEY_MIN,
     g_param_spec_int64 ("search_key_min",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_GET_RANGE_ARGS_SEARCH_KEY_MAX,
     g_param_spec_int64 ("search_key_max",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
thrift_rpc_get_range_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcGetRangeArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_get_range_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcGetRangeArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_get_range_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcGetRangeArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ThriftRpcGetRangeResultProperties
{
  PROP_THRIFT_RPC_GET_RANGE_RESULT_0,
  PROP_THRIFT_RPC_GET_RANGE_RESULT_SUCCESS
};

/* reads a rpc_get_range_result object */
static gint32
thrift_rpc_get_range_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ThriftRpcGetRangeResult * this_object = THRIFT_RPC_GET_RANGE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ThriftBucketValue * _elem4 = NULL;
              if ( _elem4 != NULL)
              {
                g_object_unref (_elem4);
              }
              _elem4 = g_object_new (THRIFT_TYPE_BUCKET_VALUE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem4), protocol, error)) < 0)
              {
                g_object_unref (_elem4);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem4);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thrift_rpc_get_range_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ThriftRpcGetRangeResult * this_object = THRIFT_RPC_GET_RANGE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RpcGetRangeResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i5;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i5 = 0; i5 < (this_object->success ? this_object->success->len : 0); i5++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i5))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thrift_rpc_get_range_result_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  ThriftRpcGetRangeResult *self = THRIFT_RPC_GET_RANGE_RESULT (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_GET_RANGE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thrift_rpc_get_range_result_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  ThriftRpcGetRangeResult *self = THRIFT_RPC_GET_RANGE_RESULT (object);

  switch (property_id)
  {
    case PROP_THRIFT_RPC_GET_RANGE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thrift_rpc_get_range_result_instance_init (ThriftRpcGetRangeResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
}

static void 
thrift_rpc_get_range_result_finalize (GObject *object)
{
  ThriftRpcGetRangeResult *tobject = THRIFT_RPC_GET_RANGE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
}

static void
thrift_rpc_get_range_result_class_init (ThriftRpcGetRangeResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thrift_rpc_get_range_result_read;
  struct_class->write = thrift_rpc_get_range_result_write;

  gobject_class->finalize = thrift_rpc_get_range_result_finalize;
  gobject_class->get_property = thrift_rpc_get_range_result_get_property;
  gobject_class->set_property = thrift_rpc_get_range_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THRIFT_RPC_GET_RANGE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
thrift_rpc_get_range_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ThriftRpcGetRangeResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thrift_rpc_get_range_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ThriftRpcGetRangeResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thrift_rpc_get_range_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ThriftRpcGetRangeResultType",
                                   &type_info, 0);
  }

  return type;
}

